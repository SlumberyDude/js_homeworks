# Task 1
## Побитовый оператор и значение
важность: 5

Почему побитовые операции в примерах ниже не меняют число? Что они делают внутри?
```js
alert( 123 ^ 0 ); // 123
alert( 0 ^ 123 ); // 123
alert( ~~123 ); // 123
```

## Решение
Первые 2 операции проводят исключающее "или" с нулевыми битами, что всегда дает то же самое число. 3я операция проводит двойное отрицание, что инвертирует биты числа дважды и в итоге его не меняет.

# Task 2
## Проверка, целое ли число
важность: 3

Напишите функцию `isInteger(num)`, которая возвращает `true`, если `num` – целое число, иначе `false`.

Например:
```js
alert( isInteger(1) ); // true
alert( isInteger(1.5) ); // false
alert( isInteger(-0.5) ); // false
```

## Решение
см. `2.html`

# Task 3
## Симметричны ли операции ^, |, &?
важность: 5

Верно ли, что для любых a и b выполняются равенства ниже?
```js
(a ^ b) == (b ^ a)
(a & b) == (b & a)
(a | b) == (b | a)
```
Иными словами, при перемене мест – всегда ли результат останется тем же?

## Решение
Верно, так как данные логические операции коммутативны.

# Task 4
## Почему результат разный?
важность: 5

Почему результат второго alert'а такой странный?
```js
alert( 123456789 ^ 0 ); // 123456789
alert( 12345678912345 ^ 0 ); // 1942903641
```

## Решение
Так как второе число превышает 32 бит и будет преобразовано побитовой операцией к 32-битному формату с потерей данных в старших битах.